// ==UserScript==
// @name         Threads Custom Buttons 3
// @namespace    http://tampermonkey.net/
// @version      14.0
// @description  Add custom buttons to Threads posts
// @author       You
// @match        https://threads.net/*
// @match        https://www.threads.net/*
// @match        https://threads.com/*
// @match        https://www.threads.com/*
// @grant        none
// ==/UserScript==


(function() {
    'use strict';

    // Track processed posts to avoid duplicates
    const processedPosts = new Set();

    // CSS for custom buttons
    const customCSS = `
        .custom-threads-button {
            display: flex;
            align-items: center;
            justify-content: flex-start;
            width: 100%;
            padding: 12px 16px;
            border: none;
            background: none;
            cursor: pointer;
            font-size: 15px;
            line-height: 20px;
            color: rgb(243, 245, 247);
            text-align: left;
            transition: background-color 0.2s ease;
        }

        .custom-threads-button:hover {
            background-color: rgba(255, 255, 255, 0.1);
        }

        .custom-button-icon {
            width: 16px;
            height: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 16px;
            line-height: 1;
        }

        .custom-buttons-container {
            display: flex;
            gap: 8px;
            margin-top: 8px;
            margin-left: 48px; /* Align with content column */
        }

        .custom-button-compact {
            padding: 6px;
            border-radius: 50%;
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(255, 255, 255, 0.1);
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            width: 32px;
            height: 32px;
            transition: all 0.2s ease;
            color: rgb(168, 178, 191);
        }

        .custom-button-compact:hover {
            background: rgba(255, 255, 255, 0.1);
            color: rgb(243, 245, 247);
            transform: scale(1.05);
        }

        .custom-button-compact.mute-btn:hover {
            background: rgba(255, 193, 7, 0.1);
            color: rgb(255, 193, 7);
        }

        .custom-button-compact.block-btn:hover {
            background: rgba(220, 53, 69, 0.1);
            color: rgb(220, 53, 69);
        }

        .custom-button-compact.not-interested-btn:hover {
            background: rgba(108, 117, 125, 0.1);
            color: rgb(108, 117, 125);
        }

        .custom-button-processing {
            opacity: 0.5;
            pointer-events: none;
        }
    `;

    // Add CSS to page
    function addCustomCSS() {
        const style = document.createElement('style');
        style.textContent = customCSS;
        document.head.appendChild(style);
    }

    // Find existing more menu button for a post container - IMPROVED VERSION
    function findMoreMenuButton(postContainer) {
        console.log('Looking for more menu button in:', postContainer);

        // Method 1: Look for SVG with "More" aria-label
        const moreSvgs = postContainer.querySelectorAll('svg[aria-label="More"]');
        console.log('Found SVGs with More aria-label:', moreSvgs.length);

        for (let svg of moreSvgs) {
            const button = svg.closest('[role="button"]') || svg.closest('button');
            if (button) {
                console.log('Found more button via SVG aria-label');
                return button;
            }
        }

        // Method 2: Look for three-dot pattern in SVG
        const allSvgs = postContainer.querySelectorAll('svg');
        console.log('Total SVGs found:', allSvgs.length);

        for (let svg of allSvgs) {
            const circles = svg.querySelectorAll('circle');
            if (circles.length === 3) {
                // Check if circles are in the three-dot pattern
                let isThreeDot = true;
                for (let circle of circles) {
                    const cy = circle.getAttribute('cy');
                    const cx = circle.getAttribute('cx');
                    if (cy !== '12' || !['6', '12', '18'].includes(cx)) {
                        isThreeDot = false;
                        break;
                    }
                }

                if (isThreeDot) {
                    const button = svg.closest('[role="button"]') || svg.closest('button');
                    if (button) {
                        console.log('Found more button via three-dot pattern');
                        return button;
                    }
                }
            }
        }

        // Method 3: Look for button with specific viewBox that contains three circles
        const buttonElements = postContainer.querySelectorAll('[role="button"], button');
        console.log('Total buttons found:', buttonElements.length);

        for (let button of buttonElements) {
            const svg = button.querySelector('svg[viewBox="0 0 24 24"]');
            if (svg) {
                const circles = svg.querySelectorAll('circle');
                if (circles.length === 3) {
                    console.log('Found more button via button search');
                    return button;
                }
            }
        }

        console.log('More menu button not found');
        return null;
    }

    // Extract username from post
    function extractUsername(postContainer) {
        // Look for username link
        const usernameLink = postContainer.querySelector('a[href^="/@"]');
        if (usernameLink) {
            return usernameLink.getAttribute('href').replace('/@', '');
        }
        return null;
    }

    // Create custom button icons using emojis
    function createButtonIcon(type) {
        const span = document.createElement('span');
        span.style.fontSize = '16px';
        span.style.lineHeight = '1';
        span.setAttribute('class', 'custom-button-icon');

        switch (type) {
            case 'mute':
                span.textContent = '🙊';
                break;
            case 'block':
                span.textContent = '🚫';
                break;
            case 'not-interested':
                span.textContent = '😒';
                break;
            default:
                span.textContent = '❓';
        }

        return span;
    }

    // Create custom buttons
    function createCustomButtons(postContainer, postId) {
        const buttonsContainer = document.createElement('div');
        buttonsContainer.className = 'custom-buttons-container';
        buttonsContainer.setAttribute('data-post-id', postId);

        const username = extractUsername(postContainer);

        // Mute button
        const muteButton = document.createElement('button');
        muteButton.className = 'custom-button-compact mute-btn';
        muteButton.title = `Mute ${username || 'this user'}`;
        muteButton.appendChild(createButtonIcon('mute'));
        muteButton.onclick = (e) => {
            e.preventDefault();
            e.stopPropagation();
            handleMuteUser(postContainer, postId, muteButton);
        };

        // Block button
        const blockButton = document.createElement('button');
        blockButton.className = 'custom-button-compact block-btn';
        blockButton.title = `Block ${username || 'this user'}`;
        blockButton.appendChild(createButtonIcon('block'));
        blockButton.onclick = (e) => {
            e.preventDefault();
            e.stopPropagation();
            handleBlockUser(postContainer, postId, blockButton);
        };

        // Not interested button
        const notInterestedButton = document.createElement('button');
        notInterestedButton.className = 'custom-button-compact not-interested-btn';
        notInterestedButton.title = 'Not interested in this post';
        notInterestedButton.appendChild(createButtonIcon('not-interested'));
        notInterestedButton.onclick = (e) => {
            e.preventDefault();
            e.stopPropagation();
            handleNotInterested(postContainer, postId, notInterestedButton);
        };

        buttonsContainer.appendChild(muteButton);
        buttonsContainer.appendChild(blockButton);
        buttonsContainer.appendChild(notInterestedButton);

        return buttonsContainer;
    }

    // Simplified menu item finder
    function findMenuItemByText(text) {
        return new Promise((resolve) => {
            const checkForMenuItem = () => {
                // Look for spans containing the exact text
                const spans = document.querySelectorAll('span');
                for (let span of spans) {
                    if (span.textContent && span.textContent.trim() === text) {
                        const button = span.closest('[role="button"]');
                        if (button) {
                            console.log(`Found menu item: ${text}`);
                            resolve(button);
                            return;
                        }
                    }
                }
                console.log(`Menu item not found: ${text}`);
                resolve(null);
            };

            // Check immediately
            checkForMenuItem();

            // Also check after short delays to account for animation
            setTimeout(checkForMenuItem, 200);
            setTimeout(checkForMenuItem, 500);
        });
    }

    // Action handlers using Threads' actual menu system
    async function handleMuteUser(postContainer, postId, button) {
        try {
            button.classList.add('custom-button-processing');
            console.log('Attempting to mute user for post:', postId);

            const moreButton = findMoreMenuButton(postContainer);
            if (!moreButton) {
                throw new Error('More menu button not found');
            }

            console.log('Clicking more menu button');
            moreButton.click();

            // Wait for menu animation
            await new Promise(resolve => setTimeout(resolve, 800));

            // Find mute button more reliably
            const muteButton = await findMenuItemByText('Mute');
            if (muteButton) {
                console.log('Clicking mute button');
                muteButton.click();
                console.log('Successfully muted user');

                // Hide the post with a fade effect
                postContainer.style.transition = 'opacity 0.5s ease';
                postContainer.style.opacity = '0.5';

                // Add a visual indicator
                const indicator = document.createElement('div');
                indicator.textContent = 'User muted';
                indicator.style.cssText = 'position: absolute; top: 10px; right: 10px; background: rgba(255,193,7,0.9); color: white; padding: 4px 8px; border-radius: 4px; font-size: 12px; z-index: 1000;';
                postContainer.style.position = 'relative';
                postContainer.appendChild(indicator);
                setTimeout(() => indicator.remove(), 3000);
            } else {
                throw new Error('Mute menu item not found');
            }
        } catch (error) {
            console.error('Error muting user:', error);
        } finally {
            button.classList.remove('custom-button-processing');
        }
    }

    async function handleBlockUser(postContainer, postId, button) {
        try {
            button.classList.add('custom-button-processing');
            console.log('Attempting to block user for post:', postId);

            const moreButton = findMoreMenuButton(postContainer);
            if (!moreButton) {
                throw new Error('More menu button not found');
            }

            console.log('Clicking more menu button');
            moreButton.click();

            // Wait for menu animation
            await new Promise(resolve => setTimeout(resolve, 800));

            // Find block button
            const blockButton = await findMenuItemByText('Block');
            if (blockButton) {
                console.log('Clicking block button');
                blockButton.click();

                // Wait for dialog
                await new Promise(resolve => setTimeout(resolve, 800));

                // Find confirmation button in dialog
                const confirmButton = await findMenuItemByText('Block');
                if (confirmButton) {
                    console.log('Clicking confirm block button');
                    confirmButton.click();
                    console.log('Successfully blocked user');

                    // Hide the post completely
                    postContainer.style.transition = 'all 0.5s ease';
                    postContainer.style.opacity = '0';
                    postContainer.style.transform = 'scale(0.95)';
                    setTimeout(() => {
                        postContainer.style.display = 'none';
                    }, 500);
                } else {
                    throw new Error('Block confirmation button not found');
                }
            } else {
                throw new Error('Block menu item not found');
            }
        } catch (error) {
            console.error('Error blocking user:', error);
        } finally {
            button.classList.remove('custom-button-processing');
        }
    }

    async function handleNotInterested(postContainer, postId, button) {
        try {
            button.classList.add('custom-button-processing');
            console.log('Attempting to mark post as not interested:', postId);

            const moreButton = findMoreMenuButton(postContainer);
            if (!moreButton) {
                throw new Error('More menu button not found');
            }

            console.log('Clicking more menu button');
            moreButton.click();

            // Wait for menu animation
            await new Promise(resolve => setTimeout(resolve, 800));

            // Find "Not interested" button
            const notInterestedButton = await findMenuItemByText('Not interested');
            if (notInterestedButton) {
                console.log('Clicking not interested button');
                notInterestedButton.click();
                console.log('Successfully marked as not interested');

                // Hide the post with a slide effect
                postContainer.style.transition = 'all 0.5s ease';
                postContainer.style.opacity = '0';
                postContainer.style.transform = 'translateX(-20px)';
                setTimeout(() => {
                    postContainer.style.display = 'none';
                }, 500);

                // Add a visual indicator
                const indicator = document.createElement('div');
                indicator.textContent = 'Marked as not interested';
                indicator.style.cssText = 'position: absolute; top: 10px; right: 10px; background: rgba(108,117,125,0.9); color: white; padding: 4px 8px; border-radius: 4px; font-size: 12px; z-index: 1000;';
                postContainer.style.position = 'relative';
                postContainer.appendChild(indicator);
            } else {
                throw new Error('Not interested menu item not found');
            }
        } catch (error) {
            console.error('Error marking as not interested:', error);
        } finally {
            button.classList.remove('custom-button-processing');
        }
    }

    // Process individual post
    function processPost(postContainer) {
        // FIRST - Check if buttons already exist to prevent duplicates
        if (postContainer.querySelector('.custom-buttons-container')) {
            return; // Already has buttons, skip
        }

        // Generate a more reliable unique ID for this post
        let postId = '';

        // Method 1: Try to get post URL
        const postLink = postContainer.querySelector('a[href*="/post/"]');
        if (postLink) {
            postId = postLink.getAttribute('href').split('/').pop();
        }
        // Method 2: Try username + timestamp
        else {
            const usernameLink = postContainer.querySelector('a[href^="/@"]');
            const timeElement = postContainer.querySelector('time[datetime]');
            if (usernameLink && timeElement) {
                const username = usernameLink.getAttribute('href').replace('/@', '');
                const timestamp = timeElement.getAttribute('datetime');
                postId = `${username}-${timestamp}`;
            }
        }

        // Method 3: Use container-based ID (fallback)
        if (!postId) {
            // Create ID based on post content hash
            const textContent = postContainer.textContent || '';
            const username = extractUsername(postContainer) || 'unknown';
            postId = `${username}-${textContent.substring(0, 50).replace(/\s+/g, '-')}`;
        }

        // Skip if already processed
        if (processedPosts.has(postId)) {
            return;
        }

        // Double-check for existing buttons one more time
        if (postContainer.querySelector('.custom-buttons-container')) {
            processedPosts.add(postId); // Mark as processed even though we're not adding buttons
            return;
        }

        // Mark as processed BEFORE creating buttons
        processedPosts.add(postId);

        // Create and insert custom buttons
        const customButtons = createCustomButtons(postContainer, postId);

        // Insert into the post grid structure
        // Look for the last content row to append after
        const gridContainer = postContainer.querySelector('[style*="grid"]') || postContainer;
        gridContainer.appendChild(customButtons);

        console.log('Added custom buttons to post:', postId);
    }

    // Process all visible posts
    function processAllPosts() {
        // Wait for initial content load
        const pressableContainers = document.querySelectorAll('[data-pressable-container="true"]');

        pressableContainers.forEach(container => {
            // Find the parent post container
            let postContainer = container.closest('[style*="grid"]') ||
                               container.closest('article') ||
                               container;

            if (postContainer) {
                processPost(postContainer);
            }
        });
    }

    // Set up mutation observer for dynamic content
    function setupMutationObserver() {
        let processingTimeout;

        const observer = new MutationObserver((mutations) => {
            let shouldProcess = false;

            mutations.forEach((mutation) => {
                if (mutation.type === 'childList') {
                    mutation.addedNodes.forEach((node) => {
                        if (node.nodeType === 1) { // Element node
                            // Only process if new pressable containers are added
                            if (node.querySelector && node.querySelector('[data-pressable-container="true"]')) {
                                shouldProcess = true;
                            }
                            // Also check if the node itself is a pressable container
                            if (node.hasAttribute && node.hasAttribute('data-pressable-container')) {
                                shouldProcess = true;
                            }
                        }
                    });
                }
            });

            if (shouldProcess) {
                // Clear any existing timeout
                clearTimeout(processingTimeout);
                // Debounce processing with longer delay
                processingTimeout = setTimeout(() => {
                    console.log('Processing new posts due to DOM changes...');
                    processAllPosts();
                }, 1000);
            }
        });

        observer.observe(document.body, {
            childList: true,
            subtree: true
        });

        console.log('Mutation observer set up');
    }

    // Initialize the script
    function initialize() {
        // Add custom CSS
        addCustomCSS();

        // Wait for initial page load
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', () => {
                setTimeout(() => {
                    processAllPosts();
                    setupMutationObserver();
                }, 1000);
            });
        } else {
            setTimeout(() => {
                processAllPosts();
                setupMutationObserver();
            }, 1000);
        }
    }

    // Start the script
    initialize();

})();
